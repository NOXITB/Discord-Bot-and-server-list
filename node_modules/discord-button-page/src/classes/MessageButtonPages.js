const { Structures, MessageEmbed, Client } = require("discord.js");
const { resolveString } = require('discord.js').Util;
const { MessageButton, MessageActionRow } = require('discord-buttons');
const Util = require('./Util.js');

class MessageButtonPages {

  constructor() {

    /**
     * Embed Options
     * @type {string}
     */
    this.embed = [null];

    /**
     * Channel Options
     * @type {string}
     */
    this.channel = null;

    /**
     * Text Author Message
     * @type {string} text textAuthor text
     * @type {boolean} reaction textAuthor reaction
     */
    this.textAuthor = {
      text: null, 
      reaction: false
    };

    /**
     * Time Duration
     * @type {number}
     */
    this.duration = null;

    /**
     * Count Pages(1/3)
     * @type {boolean}
     */
    this.countPage = true;

    /**
     * Emoji
     * @type {string} previous emoji
     * @type {string} stop emoji
     * @type {string} next emoji
     */
    this.emoji = {
      previous: "‚¨ÖÔ∏è",
      stop: "‚ùå",
      next: "‚û°Ô∏è"
    };

    /**
     * Color
     * @type {string} previous color
     * @type {string} stop color
     * @type {string} next color
     */
    this.color = {
      previous: "grey",
      stop: "red",
      next: "grey"
    };

    this.currentPage = 0;
  }

  /** 
   * Set Embed Pages.
   * @param {string} [embed, anotherEmbed] Embed options.
   * @returns {MessageButtonPages}
   */
  setEmbed(embed) {
    if (!embed) throw new TypeError('EMBED_OPTION: This option must have an embed!');
    this.embed = embed;
    return this;
  }

  /** 
   * Set Option Channel.
   * @param {string} channel options.
   * @returns {MessageButtonPages}
   */
  setChannel(option) {
    this.channel = option;
    return this;
  }

  /** 
   * Set Message Author.
   * @param {string} Text message.
   * @param {boolean} [reaction=false](Disable react emoji), Change it to true (Enable react emoji to message). 
   * @returns {MessageButtonPages}
   */
  setMessage(text, reaction = false) {
    if (!text || typeof text !== "string") throw new TypeError('MISSING_TEXT: On this option must have a string!');
    this.textAuthor.text = resolveString(text);

    if (reaction === false) this.textAuthor.reaction = false;
    else this.textAuthor.reaction = true;
    return this;
  }
  
  /** 
   * Set Duration.
   * @param {number} MS number time.
   * @returns {MessageButtonPages}
   */
  setDuration(time) {
    if (!time || typeof time !== "number") throw new TypeError('DURATION: On this option must be a number (MS) time!');
    this.duration = time;
    return this;
  }

  /** 
   * Set Count Page (1/3)
   * @param {boolean} [count=true], Change it to false if you want disable it.
   * @returns {MessageButtonPages}
   */
  setCountPage(count) {
    if (count === false) this.countPage = false;
    else this.countPage = true;
    return this;
  }

  /** 
   * Set Emoji
   * @param {string} Emoji of previous.
   * @param {string} Emoji of stop.
   * @param {string} Emoji of next.
   * @returns {MessageButtonPages}
   */
  setEmoji(previous = "‚¨ÖÔ∏è", stop = "‚ùå", next = "‚û°Ô∏è") {
    this.emoji.previous = previous && typeof previous === "string" ? previous : "‚¨ÖÔ∏è";
    this.emoji.stop = stop && typeof stop === "string" ? stop : "‚ùå";
    this.emoji.next = next && typeof next === "string" ? next : "‚û°Ô∏è";
    return this;
  }

  /** 
   * Set Color
   * @param {string} Color of previous.
   * @param {string} Color of stop.
   * @param {string} Color of next.
   * @returns {MessageButtonPages}
   */
  setColor(previous = "grey", stop = "red", next = "grey") {
    this.color.previous = previous && typeof previous === "string" ? previous : "grey";
    this.color.stop = stop && typeof stop === "string" ? stop : "red";
    this.color.next = next && typeof next === "string" ? next : "grey";
    return this;
  }



  buttonPages(message) {
    if (!message) throw new SyntaxError("'BUTTONPAGES': Please async it with 'message'!");
    
    if (this.embed.length === 0) throw new TypeError("MISSING_EMBED: No embed founded!");
    if (this.embed.length < 2) throw new TypeError("EMBED: Minimal embed is 2!");
    
    if (this.countPage === true) this.embed[0].setFooter(`Page: 1/${this.embed.length}`).setTimestamp(Date.now());
    if (this.countPage === false) this.embed[0];

    if (this.color.previous == "url") throw new TypeError("INVALID_PREVIOUS_COLOR: An invalid button color was provided!");
    if (this.color.stop === "url") throw new TypeError("INVALID_STOP_COLOR: An invalid button color was provided!");
    if (this.color.next === "url") throw new TypeError("INVALID_NEXT_COLOR: An invalid button color was provided!");
    
    let buttonPrevious = new MessageButton().setID("previous").setStyle(this.color.previous).setEmoji(this.emoji.previous).setDisabled();
    let buttonStop = new MessageButton().setID("stop").setStyle(this.color.stop).setEmoji(this.emoji.stop);
    let buttonNext = new MessageButton().setID("next").setStyle(this.color.next).setEmoji(this.emoji.next);

    const row = new MessageActionRow().addComponents(buttonPrevious, buttonStop, buttonNext);

    if (this.channel === message.author) {

      if (!this.textAuthor.reaction) {
        message.channel.send(this.textAuthor.text).catch(() => null);
        Util.authorPage([message, row], [this.embed, this.channel, this.duration, this.countPage, this.currentPage], [this.emoji.previous, this.emoji.stop, this.emoji.next], [this.color.previous, this.color.stop, this.color.next]);
      } else {
        message.react("üì¨");
        message.channel.send(this.textAuthor.text).catch(() => null);
        Util.authorPage([message, row], [this.embed, this.channel, this.duration, this.countPage, this.currentPage], [this.emoji.previous, this.emoji.stop, this.emoji.next], [this.color.previous, this.color.stop, this.color.next]);
      }

    } else {

      return message.channel.send({ embed: this.embed[0], components: row }).then(msg => {
        this.msg = msg;

        const filter = (buttons) => buttons.clicker.id === message.author.id;
        const collector = msg.createButtonCollector(filter, { time: this.duration });

        collector.on("collect", (button) => {
          button.reply.defer();
          if (button.id === "previous") {
            this.previousPage(button);
          }
          else if (button.id === "stop") {
            this.stopPage(message);
          }
          else if (button.id === "next") {
            this.nextPage(button);
          }
        });

        collector.on("end", (collected) => {
          let buttonPrevious1 = new MessageButton().setID("previous").setStyle(this.color.previous).setEmoji(this.emoji.previous).setDisabled();
          let buttonStop1 = new MessageButton().setID("stop").setStyle(this.color.stop).setEmoji(this.emoji.stop).setDisabled();
          let buttonNext1 = new MessageButton().setID("next").setStyle(this.color.next).setEmoji(this.emoji.next).setDisabled();

          let row = new MessageActionRow().addComponents(buttonPrevious1, buttonStop1, buttonNext1);
          const embed = this.embed[this.currentPage];
          this.msg.edit(embed, { components: [row] }).catch(() => null);
        });

      });
    }
  }



  /**
   * Previous Pages
   * @returns {void}
   * @ignore
   * @private
   */
  previousPage(button) {
    if (!this.msg) throw new Error("EMBED: Can't back embed before!");
    this.currentPage--;
    const embed = this.embed[this.currentPage];
    if (this.countPage) embed.setFooter(`Page: ${this.currentPage + 1}/${this.embed.length}`).setTimestamp(Date.now());

    if (this.currentPage <= 0) {
      let buttonPrevious1 = new MessageButton().setID("previous").setStyle(this.color.previous).setEmoji(this.emoji.previous).setDisabled();
      let buttonStop1 = new MessageButton().setID("stop").setStyle(this.color.stop).setEmoji(this.emoji.stop)
      let buttonNext1 = new MessageButton().setID("next").setStyle(this.color.next).setEmoji(this.emoji.next)

      let row = new MessageActionRow().addComponents(buttonPrevious1, buttonStop1, buttonNext1);
      this.msg.edit(embed, { components: [row] });
    }else if (this.currentPage <= this.embed.length) {
      let buttonPrevious1 = new MessageButton().setID("previous").setStyle(this.color.previous).setEmoji(this.emoji.previous);
      let buttonStop1 = new MessageButton().setID("stop").setStyle(this.color.stop).setEmoji(this.emoji.stop);
      let buttonNext1 = new MessageButton().setID("next").setStyle(this.color.next).setEmoji(this.emoji.next);

      let row = new MessageActionRow().addComponents(buttonPrevious1, buttonStop1, buttonNext1);
      this.msg.edit(embed, { components: [row] });
    }
  }



  /**
   * Stop Pages
   * @returns {void}
   * @ignore
   * @private
   */
  stopPage(message) {
    if (!this.msg) throw new Error("EMBED: Can't stop embed!");
    let embed = new MessageEmbed().setColor("RED").setDescription('The page has been stoped!').setTimestamp(Date.now());
    this.msg.delete().catch(() => null);
    if (this.channel === message.author) {
      this.channel.send(embed);
    } else {
      message.channel.send(embed);
    }
  }



  /**
   * Next Pages
   * @returns {void}
   * @ignore
   * @private
   */
  nextPage(button) {
    if (!this.msg) throw new Error("EMBED: Can't next the page!");
    this.currentPage++;
    const embed = this.embed[this.currentPage];
    if (this.countPage) embed.setFooter(`Page: ${this.currentPage + 1}/${this.embed.length}`).setTimestamp(Date.now());
    if (this.currentPage >= this.embed.length - 1) {
      let buttonPrevious1 = new MessageButton().setID("previous").setStyle(`${this.color.previous}`).setEmoji(this.emoji.previous);
      let buttonStop1 = new MessageButton().setID("stop").setStyle(`${this.color.stop}`).setEmoji(this.emoji.stop);
      let buttonNext1 = new MessageButton().setID("next").setStyle(`${this.color.next}`).setEmoji(this.emoji.next).setDisabled();

      let row = new MessageActionRow().addComponents(buttonPrevious1, buttonStop1, buttonNext1);
      this.msg.edit(embed, { components: [row] });
    } else if (this.currentPage > 0) {
      let buttonPrevious1 = new MessageButton().setID("previous").setStyle(this.color.previous).setEmoji(this.emoji.previous);
      let buttonStop1 = new MessageButton().setID("stop").setStyle(this.color.stop).setEmoji(this.emoji.stop);
      let buttonNext1 = new MessageButton().setID("next").setStyle(this.color.next).setEmoji(this.emoji.next);

      let row = new MessageActionRow().addComponents(buttonPrevious1, buttonStop1, buttonNext1);
      this.msg.edit(embed, { components: [row] });
    }
  }
}

module.exports = MessageButtonPages;