const { MessageEmbed } = require('discord.js');

class MessageReactionPages {
  
  constructor() {

    /**
     * Embed Options
     * @type {string}
     */
    this.embed = [null];
    
    /**
     * Time Duration
     * @type {number}
     */
    this.duration = null;
    
    /**
     * Count Pages(1/3)
     * @type {boolean}
     */
    this.countPage = true;

    /**
     * Emoji
     * @type {string} previous emoji
     * @type {string} stop emoji
     * @type {string} next emoji
     */
    this.emoji = {
      previous: "⬅️",
      stop: "❌",
      next: "➡️"
    };

    this.currentPage = 0;
  }

  /** 
   * Set Embed Pages.
   * @param {string} [embed, anotherEmbed] Embed options.
   * @returns {MessageButtonPages}
   */
  setEmbed(embed) {
    if (!embed) throw new TypeError('EMBED_OPTION: This option must have an embed!');
    this.embed = embed;
    return this;
  }

  /** 
   * Set Duration.
   * @param {number} MS number time.
   * @returns {MessageButtonPages}
   */
  setDuration(time) {
    if (!time || typeof time !== "number") throw new TypeError('DURATION: On this option must be a number (MS) time!');
    this.duration = time;
    return this;
  }

  /** 
   * Set Count Page (1/3)
   * @param {boolean} [count=true], Change it to false if you want disable it.
   * @returns {MessageButtonPages}
   */
  setCountPage(count) {
    if (count === false) this.countPage = false;
    else this.countPage = true;
    return this;
  }

  /** 
   * Set Emoji
   * @param {string} Emoji of previous.
   * @param {string} Emoji of stop.
   * @param {string} Emoji of next.
   * @returns {MessageButtonPages}
   */
  setEmoji(previous = "⬅️", stop = "❌", next = "➡️") {
    if (previous === stop || stop === next || next === previous) throw new TypeError('EMOJI: On this option must be not same emoji!');
    this.emoji.previous = previous && typeof previous === "string" ? previous : "⬅️";
    this.emoji.stop = stop && typeof stop === "string" ? stop : "❌";
    this.emoji.next = next && typeof next === "string" ? next : "➡️";
    return this;
  }



  reactionPages(message) {
    if (!message) throw new SyntaxError("'REACTIONPAGES': Please async it with 'message'!");

    if (this.embed.length === 0) throw new TypeError("MISSING_EMBED: No embed founded!");
    if (this.embed.length < 2) throw new TypeError("EMBED: Minimal embed is 2!");
    
    if (this.countPage === true) this.embed[0].setFooter(`Page: 1/${this.embed.length}`).setTimestamp(Date.now());
    if (this.countPage === false) this.embed[0];

    return message.channel.send({ embed: this.embed[0] }).then(msg => {
      this.msg = msg;
      this.msg.react(this.emoji.stop).catch(() => { throw new TypeError("INVALID_STOP_EMOJI: Please provided an valid emoji!") });
      this.msg.react(this.emoji.next).catch(() => { throw new TypeError("INVALID_NEXT_EMOJI: Please provided an valid emoji!") });

      const filter = (reaction, user) => {
        if (user.id === message.author.id) return true;
        if (user.bot) return false;
      }
      const collector = msg.createReactionCollector(filter, { time: this.duration, dispose: true });

      collector.on("collect", (reaction) => {
        switch(reaction.emoji.name) {
          case this.emoji.previous: this.previousPages();
          case this.emoji.stop: this.stopPages(message);
          case this.emoji.next: this.nextPages();
        }

        switch(reaction.emoji.id) {
          case this.emoji.previous: this.previousPages();
          case this.emoji.stop: this.stopPages(message);
          case this.emoji.next: this.nextPages();
        }
      });

      collector.on("end", () => {
        const embed = this.embed[this.currentPage];
        this.msg.reactions.removeAll().catch(() => null);
        msg.edit(embed).catch(() => null);
      });

    });

  }



   /**
   * Previous Pages
   * @returns {void}
   * @ignore
   * @private
   */
  previousPages() {
    if (!this.msg) throw new Error("EMBED: Can't back embed before!");
    this.currentPage--;
    if (this.currentPage <= 0) {
      this.msg.reactions.removeAll();
      this.msg.react(this.emoji.stop).catch(() => { throw new TypeError("INVALID_STOP_EMOJI: Please provided an valid emoji!") });
      this.msg.react(this.emoji.next).catch(() => { throw new TypeError("INVALID_NEXT_EMOJI: Please provided an valid emoji!") });
    } else if (this.currentPage <= this.embed.length) {
      this.msg.reactions.removeAll();
      this.msg.react(this.emoji.previous).catch(() => { throw new TypeError("INVALID_PREVIOUS_EMOJI: Please provided an valid emoji!") });
      this.msg.react(this.emoji.stop).catch(() => { throw new TypeError("INVALID_STOP_EMOJI: Please provided an valid emoji!" ) });
      this.msg.react(this.emoji.next).catch(() => { throw new TypeError("INVALID_NEXT_EMOJI: Please provided an valid emoji!") });
    }
    const embed = this.embed[this.currentPage];
    if (this.countPage) embed.setFooter(`Page: ${this.currentPage + 1}/${this.embed.length}`).setTimestamp(Date.now());
    this.msg.edit({ embed: embed });
  }



  /**
   * Stop Pages
   * @returns {void}
   * @ignore
   * @private
   */
  stopPages(message) {
    if (!this.msg) throw new Error("EMBED: Can't stop embed!");
    let embed = new MessageEmbed().setColor("RED").setDescription('The page has been stoped!').setTimestamp(Date.now());
    this.msg.delete().catch(() => null);
    return message.channel.send(embed);
  }



  /**
   * Next Pages
   * @returns {void}
   * @ignore
   * @private
   */
  nextPages() {
    if (!this.msg) throw new Error("EMBED: Can't next the page!");
    this.currentPage++;
    if (this.currentPage >= this.embed.length - 1) {
      this.msg.reactions.removeAll();
      this.msg.react(this.emoji.previous).catch(() => { throw new TypeError("INVALID_PREVIOUS_EMOJI: Please provided an valid emoji!") });
      this.msg.react(this.emoji.stop).catch(() => { throw new TypeError("INVALID_STOP_EMOJI: Please provided an valid emoji!") });
    } else if (this.currentPage > 0) {
      this.msg.reactions.removeAll();
      this.msg.react(this.emoji.previous).catch(() => { throw new TypeError("INVALID_PREVIOUS_EMOJI: Please provided an valid emoji!") });
      this.msg.react(this.emoji.stop).catch(() => { throw new TypeError("INVALID_STOP_EMOJI: Please provided an valid emoji!") });
      this.msg.react(this.emoji.next).catch(() => { throw new TypeError("INVALID_NEXT_EMOJI: Please provided an valid emoji!") });
    }
    const embed = this.embed[this.currentPage];
    if (this.countPage) embed.setFooter(`Page: ${this.currentPage + 1}/${this.embed.length}`).setTimestamp(Date.now());
    this.msg.edit({ embed: embed });
  }
}

module.exports = MessageReactionPages;